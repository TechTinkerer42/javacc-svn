/* Copyright (c) 2006, Sun Microsystems, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

JJTreeExamples

This directory contains some simple JJTree input files intended to
illustrate some of the basic ideas.  All of them are based on a 
grammar to recognize arithmetic expressions built out of identifiers
and constants.

eg1.jjt

This example is just the JavaCC grammar, with a little extra code in
the parser's main method to call the dump method on the generated
tree.  It illustrates how the default behavior of JJTree will produce
a tree of non-terminals.

eg2.jjt

This example is the same grammar as eg1.jjt with modifications to
customize the generated tree.  It illustrates how unnecessary
intermediate nodes can be suppressed and how actions in the grammar
can attach extra information to the nodes.

eg3.jjt

This example is a modification of eg2.jjt with the NODE_DEFAULT_VOID
option set.  This instructs JJTree to treat all undecorated
non-terminals as if they were decorated as #void. The default JJTree
behavior is to treat such non-terminals as if they were decorated
with the name of the non-terminal.

eg4.jjt

This is a modification of eg3.jjt with the VISITOR option set.  This
instructs JJTree to insert a jjtAccept() method into all nodes it
generates, and to produce a visitor class.  The visitor is used to
dump the tree.

Here are some instructions on how to run the examples using the Ant build scripts, 
and the output you can expect to see.

eg1.jjt
-------

The only bit of JJTree-specific code is an action in the start
production that dumps the constructed parse tree when the parse is
complete.  It uses JJTree simple mode.

The input file is eg1.jjt.

$ ant -lib ../../../lib
Buildfile: Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\build.xml

eg1:
   [delete] Deleting directory Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1
    [mkdir] Created dir: Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1
     [copy] Copying 1 file to Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1
     [copy] Copying 1 file to Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1
   [jjtree] Java Compiler Compiler Version 6.2_0 (Tree Builder)
   [jjtree] (type "jjtree" with no arguments for help)
   [jjtree] Reading from file Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1.jjt . . .
   [jjtree] opt:c++
   [jjtree] File "Node.h" does not exist.  Will create one.
   [jjtree] File "ParserTree.h" does not exist.  Will create one.
   [jjtree] File "ParserTree.cc" does not exist.  Will create one.
   [jjtree] File "ParserTreeConstants.h" does not exist.  Will create one.
   [jjtree] File "JJTParserState.h" does not exist.  Will create one.
   [jjtree] File "JJTParserState.cc" does not exist.  Will create one.
   [jjtree] Annotated grammar generated successfully in Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\eg1.jj
   [javacc] Java Compiler Compiler Version 6.2_0 (Parser Generator)
   [javacc] (type "javacc" with no arguments for help)
   [javacc] Reading from file Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\eg1.jj . . .
   [javacc] File "JavaCC.h" does not exist.  Will create one.
   [javacc] File "CharStream.h" does not exist.  Will create one.
   [javacc] File "CharStream.cc" does not exist.  Will create one.
   [javacc] File "Token.h" does not exist.  Will create one.
   [javacc] File "Token.cc" does not exist.  Will create one.
   [javacc] File "TokenManager.h" does not exist.  Will create one.
   [javacc] File "TokenMgrError.h" does not exist.  Will create one.
   [javacc] File "TokenMgrError.cc" does not exist.  Will create one.
   [javacc] File "ParseException.h" does not exist.  Will create one.
   [javacc] File "ParseException.cc" does not exist.  Will create one.
   [javacc] File "Token.h" is being rebuilt.
   [javacc] File "Token.cc" is being rebuilt.
   [javacc] File "ErrorHandler.h" does not exist.  Will create one.
   [javacc] Parser generated successfully.
[cpptasks:cc] 9 total files to be compiled.
[cpptasks:cc] cygwin warning:
[cpptasks:cc]   MS-DOS style path detected: Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTree.cc
[cpptasks:cc]   Preferred POSIX equivalent is: /cygdrive/z/dev/llvm/x64/javacc~svn/examples/JJTreeExamples/cpp/eg1/ParserTree.cc
[cpptasks:cc]   CYGWIN environment variable option "nodosfilewarning" turns off this warning.
[cpptasks:cc]   Consult the user's guide for more details about POSIX paths:
[cpptasks:cc]     http://cygwin.com/cygwin-ug-net/using.html#using-pathnames
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTree.cc: In member function 'virtual void EG1::SimpleNode::jjtAddChild(EG1::Node*, int)':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTree.cc:30:28: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      if (i >= children.size()) {
[cpptasks:cc]                             ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTree.cc: In member function 'virtual EG1::Node* EG1::SimpleNode::jjtGetChild(int) const':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTree.cc:38:30: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      return i < children.size() ? children[i] : NULL;
[cpptasks:cc]                               ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTree.cc: In member function 'virtual void EG1::SimpleNode::dumpToBuffer(std::basic_string<char>, std::basic_string<char>, std::basic_string<char>*) const':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTree.cc:68:39: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      for (int i = 0; i < children.size(); ++i) {
[cpptasks:cc]                                        ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTree.cc: In member function 'virtual void EG1::SimpleNode::dump(std::basic_string<char>) const':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTree.cc:79:38: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      for (int i = 0; i < buffer->size(); i++) {
[cpptasks:cc]                                       ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTree.cc: In destructor 'virtual EG1::SimpleNode::~SimpleNode()':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTree.cc:86:39: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      for (int i = 0; i < children.size(); ++i) {
[cpptasks:cc]                                        ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\JJTParserState.cc: In member function 'virtual void EG1::JJTParserState::closeNodeScope(EG1::Node*, int)':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\JJTParserState.cc:97:25: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      if (nodes->size() < num) {
[cpptasks:cc]                          ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\JJTParserState.cc: In member function 'virtual void EG1::JJTParserState::closeNodeScope(EG1::Node*, bool)':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\JJTParserState.cc:123:27: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]        if (nodes->size() < a) {
[cpptasks:cc]                            ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTokenManager.cc: In member function 'EG1::Token* EG1::ParserTokenManager::jjFillToken()':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTokenManager.cc:359:28: warning: 'endColumn' may be used uninitialized in this function [-Wmaybe-uninitialized]
[cpptasks:cc]     t->endColumn = endColumn;
[cpptasks:cc]                             ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTokenManager.cc:358:32: warning: 'beginColumn' may be used uninitialized in this function [-Wmaybe-uninitialized]
[cpptasks:cc]     t->beginColumn = beginColumn;
[cpptasks:cc]                                 ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTokenManager.cc:357:24: warning: 'endLine' may be used uninitialized in this function [-Wmaybe-uninitialized]
[cpptasks:cc]     t->endLine = endLine;
[cpptasks:cc]                         ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg1\ParserTokenManager.cc:356:28: warning: 'beginLine' may be used uninitialized in this function [-Wmaybe-uninitialized]
[cpptasks:cc]     t->beginLine = beginLine;
[cpptasks:cc]                             ^
[cpptasks:cc] Starting link
     [exec] Reading from standard input...
     [exec] Start
     [exec]  Expression
     [exec]   AdditiveExpression
     [exec]    MultiplicativeExpression
     [exec]     UnaryExpression
     [exec]      Expression
     [exec]       AdditiveExpression
     [exec]        MultiplicativeExpression
     [exec]         UnaryExpression
     [exec]          Integer
     [exec]        MultiplicativeExpression
     [exec]         UnaryExpression
     [exec]          Integer
     [exec]     UnaryExpression
     [exec]      Expression
     [exec]       AdditiveExpression
     [exec]        MultiplicativeExpression
     [exec]         UnaryExpression
     [exec]          Identifier
     [exec]        MultiplicativeExpression
     [exec]         UnaryExpression
     [exec]          Identifier
     [exec] thank you.

BUILD SUCCESSFUL
Total time: 4 seconds

eg2.jjt
-------

This is a modification of the first example to illustrate how the
parse tree can be customized: But the current generated code for JavaCC 6.2.1 fails 
to customize ASTMyID and so eg2 does not work.

$ ant -lib ../../../lib eg2
Buildfile: Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\build.xml

eg2:
    [mkdir] Created dir: Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2
     [copy] Copying 1 file to Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2
     [copy] Copying 1 file to Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2
   [jjtree] Java Compiler Compiler Version 6.2_0 (Tree Builder)
   [jjtree] (type "jjtree" with no arguments for help)
   [jjtree] Reading from file Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2.jjt . . .
   [jjtree] opt:c++
   [jjtree] File "Node.h" does not exist.  Will create one.
   [jjtree] File "ParserTree.h" does not exist.  Will create one.
   [jjtree] File "ParserTree.cc" does not exist.  Will create one.
   [jjtree] File "ParserTreeConstants.h" does not exist.  Will create one.
   [jjtree] File "JJTParserState.h" does not exist.  Will create one.
   [jjtree] File "JJTParserState.cc" does not exist.  Will create one.
   [jjtree] Annotated grammar generated successfully in Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\eg2.jj
   [javacc] Java Compiler Compiler Version 6.2_0 (Parser Generator)
   [javacc] (type "javacc" with no arguments for help)
   [javacc] Reading from file Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\eg2.jj . . .
   [javacc] File "JavaCC.h" does not exist.  Will create one.
   [javacc] File "CharStream.h" does not exist.  Will create one.
   [javacc] File "CharStream.cc" does not exist.  Will create one.
   [javacc] File "Token.h" does not exist.  Will create one.
   [javacc] File "Token.cc" does not exist.  Will create one.
   [javacc] File "TokenManager.h" does not exist.  Will create one.
   [javacc] File "TokenMgrError.h" does not exist.  Will create one.
   [javacc] File "TokenMgrError.cc" does not exist.  Will create one.
   [javacc] File "ParseException.h" does not exist.  Will create one.
   [javacc] File "ParseException.cc" does not exist.  Will create one.
   [javacc] File "Token.h" is being rebuilt.
   [javacc] File "Token.cc" is being rebuilt.
   [javacc] File "ErrorHandler.h" does not exist.  Will create one.
   [javacc] Parser generated successfully.
     [copy] Copying 1 file to Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2
     [copy] Copying 1 file to Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2
[cpptasks:cc] 10 total files to be compiled.
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ParserTree.cc: In member function 'virtual void EG2::SimpleNode::jjtAddChild(EG2::Node*, int)':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ParserTree.cc:30:28: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      if (i >= children.size()) {
[cpptasks:cc]                             ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ParserTree.cc: In member function 'virtual EG2::Node* EG2::SimpleNode::jjtGetChild(int) const':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ParserTree.cc:38:30: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      return i < children.size() ? children[i] : NULL;
[cpptasks:cc]                               ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ParserTree.cc: In member function 'virtual void EG2::SimpleNode::dumpToBuffer(std::basic_string<char>, std::basic_string<char>, std::basic_string<char>*) const':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ParserTree.cc:68:39: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      for (int i = 0; i < children.size(); ++i) {
[cpptasks:cc]                                        ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ParserTree.cc: In member function 'virtual void EG2::SimpleNode::dump(std::basic_string<char>) const':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ParserTree.cc:79:38: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      for (int i = 0; i < buffer->size(); i++) {
[cpptasks:cc]                                       ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ParserTree.cc: In destructor 'virtual EG2::SimpleNode::~SimpleNode()':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ParserTree.cc:86:39: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      for (int i = 0; i < children.size(); ++i) {
[cpptasks:cc]                                        ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\JJTParserState.cc: In member function 'virtual void EG2::JJTParserState::closeNodeScope(EG2::Node*, int)':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\JJTParserState.cc:97:25: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]      if (nodes->size() < num) {
[cpptasks:cc]                          ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\JJTParserState.cc: In member function 'virtual void EG2::JJTParserState::closeNodeScope(EG2::Node*, bool)':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\JJTParserState.cc:123:27: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]
[cpptasks:cc]        if (nodes->size() < a) {
[cpptasks:cc]                            ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\Parser.cc: In member function 'void EG2::Parser::MyID()':
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\Parser.cc:189:10: error: 'class EG2::ASTMyID' has no member named 'setName'
[cpptasks:cc]  jjtn000->setName(t->image);
[cpptasks:cc]           ^
[cpptasks:cc] In file included from Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ASTMyID.cc:8:0:
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ASTMyID.h:14:7: error: redefinition of 'class EG2::ASTMyID'
[cpptasks:cc]  class ASTMyID : public SimpleNode {
[cpptasks:cc]        ^
[cpptasks:cc] In file included from Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ASTMyID.h:10:0,
[cpptasks:cc]                  from Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ASTMyID.cc:8:
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ParserTree.h:75:7: error: previous definition of 'class EG2::ASTMyID'
[cpptasks:cc]  class ASTMyID : public SimpleNode {
[cpptasks:cc]        ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ASTMyID.cc:18:42: error: no 'void EG2::ASTMyID::setName(std::basic_string<char>)' member function declared in class 'EG2::ASTMyID'
[cpptasks:cc]  ASTMyID::setName(JAVACC_STRING_TYPE image) {
[cpptasks:cc]                                           ^
[cpptasks:cc] Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\eg2\ASTMyID.cc:25:40: error: no 'std::basic_string<char> EG2::ASTMyID::toString() const' member function declared in class 'EG2::ASTMyID'
[cpptasks:cc]  JAVACC_STRING_TYPE ASTMyID::toString() const {
[cpptasks:cc]                                         ^

BUILD FAILED
Z:\dev\llvm\x64\javacc~svn\examples\JJTreeExamples\cpp\build.xml:56: g++ failed with return code 1

Total time: 3 seconds

Look at eg2.jjt to see how node annotations can be used to restructure
the parse tree, and at ASTMyID.java to see how you can write your own
node classes that maintain more information from the input stream.

eg3.jjt
-------

This example can be run in the same manner as you ran eg2.jjt.But the current generated code for JavaCC 6.2.1 fails 
to customize ASTMyID and so eg3 does not work.

eg4.jjt
-------

This example again can be run in the same manner as you ran eg2.jjt.But the current generated code for JavaCC 6.2.1 fails 
to customize ASTMyID and ASTMyOtherID and so eg4 does not work.
