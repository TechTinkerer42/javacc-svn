\#include "Token.h"
/**
 * Describes the input token stream.
 */

  /**
   * An optional attribute value of the Token.
   * Tokens which are not used as syntactic sugar will often contain
   * meaningful values that will be used later on by the compiler or
   * interpreter. This attribute value is often different from the image.
   * Any subclass of Token that actually wants to return a non-NULL value can
   * override this method as appropriate.
   */
  Object _Token::getValue() {
    return NULL;
  }

  /**
   * No-argument constructor
   */
  _Token::_Token() {}

  /**
   * Constructs a new token for the specified Image.
   */
  _Token::_Token(int kind)
  {
    this->kind = kind;
  }

  /**
   * Constructs a new token for the specified Image and Kind.
   */
  _Token::_Token(int kind, String image)
  {
    this->kind = kind;
    this->image = image;
  }

  /**
   * Returns the image.
   */
  String _Token::toString()
  {
    return image;
  }

  /**
   * Returns a new Token object, by default. However, if you want, you
   * can create and return subclass objects based on the value of ofKind.
   * Simply add the cases to the switch for all those special cases.
   * For example, if you have a subclass of Token called IDToken that
   * you want to create if ofKind is ID, simply add something like :
   *
   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
   *
   * to the following switch statement. Then you can cast matchedToken
   * variable to the appropriate type and use sit in your lexical actions.
   */
  Token _Token::newToken(int ofKind, String image)
  {
    switch(ofKind)
    {
      default : return new _Token(ofKind, image);
    }
  }

  Token _Token::newToken(int ofKind)
  {
    return newToken(ofKind, NULL);
  }

  _Token::~_Token() {
    if (next) delete next;
  }
