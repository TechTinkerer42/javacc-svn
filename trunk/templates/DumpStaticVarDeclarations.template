    ${STATIC?static :}protected ${charStreamName}  input_stream;

    ${STATIC?static :}private final int[] jjrounds = new int[${stateSetSize}];
    ${STATIC?static :}private final int[] jjstateSet = new int[2 * stateSetSize];

#if hasActions
    private ${STATIC?static :}final " + Options.stringBufOrBuild() + " jjimage = new " + Options.stringBufOrBuild() + "();
    private ${STATIC?static :}StringBuilder image = jjimage;
    private ${STATIC?static :}int jjimageLen;
    private ${STATIC?static :}int lengthOfMatch;
#fi
    
    ${STATIC?static :}protected char curChar;

#if TOKEN_MANAGER_USES_PARSER && !STATIC{
    /** Constructor with parser. */
    public ${tokMgrClassName} (${cu_name} parserArg, ${charStreamName} stream){
    parser = parserArg;
#else
    /** Constructor. */
    public ${tokMgrClassName}(${charStreamName} stream){
#fi

#if STATIC && !USER_CHAR_STREAM
      if (input_stream != null)
        throw new TokenMgrError("ERROR: Second call to constructor of static lexer. You must use ReInit() to initialize the static variables.", TokenMgrError.STATIC_LEXER_ERROR);
#else
  #if USER_CHAR_STREAM
    #if JAVA_UNICODE_ESCAPE
        if (JavaCharStream.staticFlag)
    #else
        if (SimpleCharStream.staticFlag)
    #fi
            throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
    }
  #fi
#fi

    input_stream = stream;
  }

#if TOKEN_USES_PARSER && !STATIC
  /** Constructor with parser. */
  public ${tokMgrClassName} (${cu_name} parserArg, ${charStreamName} stream, int lexState){
    this(parserArg, stream);
  }
#else
  /** Constructor. */
  public ${tokMgrClassName} (${charStreamName} stream, int lexState){
    this(stream);
    SwitchTo(lexState);
  }
#fi

  // Reinit method for reinitializing the parser (for static parsers).

  /** Reinitialise parser. */
    ostr.println(${STATIC?static :}public void ReInit(" + charStreamName + " stream)
{
   jjmatchedPos = jjnewStateCnt = 0;
   curLexState = defaultLexState;
   input_stream = stream;
   ReInitRounds();
}

    // Method to reinitialize the jjrounds array.
    ostr.println(${STATIC?static :}private void ReInitRounds()
{
   int i;
   jjround = 0x" + Integer.toHexString(Integer.MIN_VALUE + 1)+ ";
   for (i = " + stateSetSize + "; i-- > 0;)
      jjrounds[i] = 0x" + Integer.toHexString(Integer.MIN_VALUE) + ";
}

    // Reinit method for reinitializing the parser (for static parsers).

/** Reinitialise parser. */
    ostr.println(${STATIC?static :}public void ReInit(" + charStreamName + " stream, int lexState)
{
   ReInit(stream);
   SwitchTo(lexState);
}


/** Switch to specified lex state. */
    ostr.println(${STATIC?static :}public void SwitchTo(int lexState)
{
   if (lexState >= " + lexStateName.length + " || lexState < 0)
      throw new TokenMgrError(\"Error: Ignoring invalid lexical state : \"" +
    " + lexState + \". State unchanged.\", TokenMgrError.INVALID_LEXICAL_STATE);
   else
      curLexState = lexState;
}

